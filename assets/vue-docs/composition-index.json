[
  {
    "title": "accessibility",
    "path": "guide/best-practices/composition/accessibility.composition.md",
    "summary": "- Web accessibility (a11y) refers to creating websites that can be used by anyone, including people with disabilities or in unfavorable environments\n- Adding a skip link at the top of each page allows users to skip repeated content\n- Properly structuring content with headings helps users navigate the application\n- Landmarks provide programmatic access to sections within an application\n- Semantic forms should use labels, instructions, and avoid using placeholders\n- Hiding content can be done using CSS or `aria-hidden=\"true\"`\n- WCAG 2.1 provides guidelines for web accessibility, including perceivability, operability, understandability, and robustness\n- WAI-ARIA provides guidance for building dynamic content and advanced user interface controls\n- Resources for testing and assistive technologies are available to ensure accessibility\n- Web accessibility benefits a large population of people with disabilities, including visual, auditory, motor, and cognitive impairments"
  },
  {
    "title": "performance",
    "path": "guide/best-practices/composition/performance.composition.md",
    "summary": "- Vue is designed to be performant for most common use cases without much need for manual optimizations\n- Two major aspects of web performance: Page Load Performance and Update Performance\n- Picking the right architecture is important for optimal performance\n- Profiling options include PageSpeed Insights, WebPageTest, Chrome DevTools Performance Panel, and Vue DevTools Extension\n- Page load optimizations include choosing the right architecture, bundle size and tree-shaking, and code splitting\n- Update optimizations include props stability, v-once, and v-memo\n- General optimizations include virtualizing large lists, reducing reactivity overhead for large immutable structures, and avoiding unnecessary component abstractions"
  },
  {
    "title": "production-deployment",
    "path": "guide/best-practices/composition/production-deployment.composition.md",
    "summary": "- Development features in Vue.js include warning for errors, props/events validation, reactivity debugging hooks, and Devtools integration\n- These features are not needed in production and can impact performance\n- When deploying Vue.js without build tools, use the production build files (dist files ending in `.prod.js`)\n- When using build tools, ensure that `vue` resolves to `vue.runtime.esm-bundler.js`, configure compile time feature flags, and replace 'process.env' with `\"production\"`\n- Use the app-level error handler in Vue.js to track runtime errors and report them to tracking services like Sentry and Bugsnag."
  },
  {
    "title": "security",
    "path": "guide/best-practices/composition/security.composition.md",
    "summary": "- Reporting vulnerabilities is a top concern for Vue.js, email [security@vuejs.org](mailto:security@vuejs.org) to report a vulnerability.\n- Never use non-trusted content as component templates, it can lead to arbitrary JavaScript execution.\n- Vue automatically escapes HTML content and dynamic attribute bindings to prevent script injection.\n- User-provided HTML, URLs, styles, and JavaScript should be sanitized and handled with caution.\n- Best practices include avoiding unsanitized user-provided content and familiarizing yourself with HTML5 security and XSS prevention resources.\n- HTTP security vulnerabilities are primarily addressed on the backend.\n- Server-side rendering has additional security concerns, follow best practices outlined in the SSR documentation."
  },
  {
    "title": "keep-alive",
    "path": "guide/built-ins/composition/keep-alive.composition.md",
    "summary": "- `<KeepAlive>` is a built-in component in Vue.js\n- It allows us to conditionally cache component instances when dynamically switching between multiple components\n- The state of the components will be persisted across switches\n- We can customize the caching behavior using the `include` and `exclude` props\n- We can limit the maximum number of cached instances using the `max` prop\n- Cached instances have lifecycle hooks for activation and deactivation"
  },
  {
    "title": "suspense",
    "path": "guide/built-ins/composition/suspense.composition.md",
    "summary": "- `<Suspense>` is a built-in component in Vue.js for handling async dependencies in a component tree\n- It can render a loading state while waiting for multiple nested async dependencies to be resolved\n- There are two types of async dependencies that `<Suspense>` can wait on: components with an async `setup()` hook and async components\n- The `<Suspense>` component has two slots: `#default` and `#fallback`, which allow for displaying content and a loading state respectively\n- `<Suspense>` emits three events: `pending`, `resolve`, and `fallback`, which can be used for showing loading indicators or handling errors\n- Error handling can be done using the `errorCaptured` option or the `onErrorCaptured()` hook in the parent component of `<Suspense>`\n- `<Suspense>` can be combined with other components like `<Transition>` and `<KeepAlive>` for more advanced functionality"
  },
  {
    "title": "teleport",
    "path": "guide/built-ins/composition/teleport.composition.md",
    "summary": "- `<Teleport>` is a built-in component in Vue.js\n- It allows us to \"teleport\" a part of a component's template outside of the DOM hierarchy\n- It is useful for scenarios like full-screen modals\n- The `to` attribute of `<Teleport>` specifies the target DOM node\n- `<Teleport>` can be combined with `<Transition>` to create animated modals\n- `<Teleport>` does not affect the logical hierarchy of components\n- It can be disabled conditionally using the `disabled` prop\n- Multiple `<Teleport>` components can mount their content to the same target element"
  },
  {
    "title": "transition-group",
    "path": "guide/built-ins/composition/transition-group.composition.md",
    "summary": "- `<TransitionGroup>` is a built-in component for animating elements in a list\n- It supports props, CSS transition classes, and JavaScript hook listeners\n- It doesn't render a wrapper element by default, but you can specify one with the `tag` prop\n- Elements inside must have a unique `key` attribute\n- CSS transition classes are applied to individual elements in the list\n- It can be used in DOM templates as `<transition-group>`\n- It can be used for enter/leave transitions, move transitions, and staggering list transitions\n- The related API reference is available for `<TransitionGroup>`"
  },
  {
    "title": "transition",
    "path": "guide/built-ins/composition/transition.composition.md",
    "summary": "- `<Transition>` is a built-in component in Vue.js for applying animations when an element or component is entering and leaving the DOM.\n- It can be triggered by conditional rendering, conditional display, dynamic component toggling, or changing the `key` attribute.\n- The component supports CSS-based transitions and animations.\n- CSS-based transitions use classes like `v-enter-from`, `v-enter-active`, `v-enter-to`, `v-leave-from`, `v-leave-active`, and `v-leave-to`.\n- CSS-based animations use classes like `bounce-enter-active`, `bounce-leave-active`, `bounce-enter-from`, and `bounce-leave-to`.\n- JavaScript hooks can be used to hook into the transition process and perform custom actions at different stages.\n- Transitions can be applied to the initial render of a node using the `appear` prop.\n- Transitions can be applied between elements using `v-if` / `v-else` / `v-else-if` statements.\n- Transitions can be applied between components using dynamic components and the `is` prop.\n- Dynamic transitions can be achieved by using dynamic props for the `name` prop."
  },
  {
    "title": "async",
    "path": "guide/components/composition/async.composition.md",
    "summary": "- `defineAsyncComponent` function is used to load a component from the server only when it's needed\n- The function accepts a loader function that returns a Promise\n- The resulting component is a wrapper that calls the loader function when rendered\n- Async components can be registered globally or defined directly inside their parent component\n- Loading and error states can be handled using advanced options such as loadingComponent, delay, errorComponent, and timeout\n- Async components can be used with the `<Suspense>` built-in component."
  },
  {
    "title": "attrs",
    "path": "guide/components/composition/attrs.composition.md",
    "summary": "- A \"fallthrough attribute\" is an attribute or `v-on` event listener that is passed to a component, but is not explicitly declared in the receiving component's props or emits.\n- Fallthrough attributes are automatically added to the root element's attributes when a component renders a single root element.\n- Fallthrough attributes like `class` and `style` can be merged with existing attributes on the child component's root element.\n- Fallthrough `v-on` event listeners are added to the root element of the component and trigger the corresponding method in the parent component.\n- Fallthrough attributes are automatically forwarded to nested components if the component renders another component as its root node.\n- Attribute inheritance can be disabled by setting `inheritAttrs: false` in the component's options.\n- Fallthrough attributes can be accessed directly in template expressions as `$attrs`.\n- Fallthrough attributes can be accessed in JavaScript using the `useAttrs()` API in `<script setup>` or as `ctx.attrs` in the `setup()` context.\n- Components with multiple root nodes do not have automatic attribute fallthrough behavior and require explicit binding of `$attrs`."
  },
  {
    "title": "events",
    "path": "guide/components/composition/events.composition.md",
    "summary": "- The page is about component events in Vue.js\n- It explains how to emit and listen to events in a component\n- It mentions the `$emit` method for emitting events in a component template\n- It shows how to listen to emitted events using `v-on`\n- It mentions the `.once` modifier for listening to an event only once\n- It explains how to pass arguments to emitted events using `$emit`\n- It shows how to access the event argument in the parent component\n- It mentions that all extra arguments passed to `$emit` will be forwarded to the listener\n- It explains how to declare emitted events using the `defineEmits` macro or the `emits` option\n- It shows how to use the `emit` function to emit events in the `<script setup>` section or the `setup()` function\n- It mentions that the `emits` option supports runtime validation of the payload of emitted events\n- It explains that defining emitted events is recommended for better documentation and to exclude known listeners from fallthrough attributes\n- It mentions that if a native event is defined in the `emits` option, the listener will only respond to component-emitted events of that type\n- It explains how to validate emitted events using a function that receives the event arguments and returns a boolean indicating validity."
  },
  {
    "title": "props",
    "path": "guide/components/composition/props.composition.md",
    "summary": "- Props in Vue.js components require explicit declaration\n- Props can be declared using the `defineProps()` macro in SFCs using `<script setup>`\n- Props can also be declared using the `props` option in non-`<script setup>` components\n- Props can be declared using an array of strings or an object syntax\n- Props can have different value types such as number, boolean, array, and object\n- Props can be passed as static values or assigned dynamically using `v-bind` or `:`\n- Props form a one-way data flow from parent to child\n- Mutating a prop inside a child component is not allowed and will result in a warning\n- Object and array props can be mutated, but it is not recommended unless the parent and child are tightly coupled\n- Props can be validated using an object with validation requirements\n- Prop validation can include basic type checks, multiple possible types, required props, default values, and custom validator functions\n- Runtime type checks can be performed using native constructors or custom classes\n- Props with `Boolean` type have special casting rules to mimic native boolean attributes"
  },
  {
    "title": "provide-inject",
    "path": "guide/components/composition/provide-inject.composition.md",
    "summary": "- The page explains how to solve the issue of prop drilling in Vue.js\n- It introduces the `provide` and `inject` functions to pass data from a parent component to its descendants\n- The `provide` function is used to provide data to descendants, and it accepts an injection key and a value\n- The `inject` function is used to inject data provided by an ancestor component, and it accepts the injection key\n- App-level provides can also be used to provide data to all components rendered in the app\n- The page also explains how to work with reactivity when using `provide` and `inject`\n- It recommends keeping mutations to reactive state inside the provider component\n- It also explains how to work with symbol keys to avoid potential collisions when using `provide` and `inject`"
  },
  {
    "title": "registration",
    "path": "guide/components/composition/registration.composition.md",
    "summary": "- Component Registration page explains the two ways to register components in Vue.js: global and local registration\n- Global Registration:\n  - Components can be registered globally using the `app.component()` method\n  - Registered components can be used in the template of any component within the application\n- Local Registration:\n  - Local registration scopes the availability of the registered components to the current component only\n  - It makes the dependency relationship more explicit and is more tree-shaking friendly\n- The page also mentions component name casing:\n  - PascalCase names are used when registering components for easier import and registration in JavaScript\n  - PascalCase also helps differentiate Vue components from custom elements\n  - Vue supports resolving kebab-case tags to components registered using PascalCase, allowing the use of both `<MyComponent>` and `<my-component>` in the template"
  },
  {
    "title": "slots",
    "path": "guide/components/composition/slots.composition.md",
    "summary": "- Slots allow passing template fragments to child components\n- `<slot>` element is a slot outlet that indicates where the parent-provided slot content should be rendered\n- Slot content can be any valid template content\n- Slots can have fallback content that is rendered when no content is provided\n- Named slots allow having multiple slot outlets in a single component\n- Dynamic directive arguments can be used to define dynamic slot names\n- Scoped slots allow passing data from the parent component to the slot content\n- Scoped slots can be used with both default and named slots\n- Renderless components are components that encapsulate logic but do not render anything themselves"
  },
  {
    "title": "v-model",
    "path": "guide/components/composition/v-model.composition.md",
    "summary": "- `v-model` can be used on a component to implement a two-way binding\n- `v-model` on a component expands to `:modelValue` and `@update:modelValue`\n- The component must bind the `value` attribute of a native `<input>` element to the `modelValue` prop and emit an `update:modelValue` event\n- Multiple `v-model` bindings can be created on a single component instance\n- Custom modifiers can be added to a component `v-model` using the `modelModifiers` prop\n- Modifiers can be used with `v-model` bindings with arguments, and the generated prop name will be `arg + \"Modifiers\"`"
  },
  {
    "title": "component-basics",
    "path": "guide/essentials/composition/component-basics.composition.md",
    "summary": "- Components allow for splitting the UI into independent and reusable pieces\n- Components can be defined using the `.vue` extension or as a plain JavaScript object\n- Components can be used by importing them in the parent component or globally registering them\n- Props can be used to pass data to a component\n- Events can be used to communicate from a child component to a parent component\n- Slots can be used to pass content to a component\n- Dynamic components can be used to switch between different components\n- DOM template parsing has some caveats such as case insensitivity, explicit closing tags, and element placement restrictions"
  },
  {
    "title": "computed",
    "path": "guide/essentials/composition/computed.composition.md",
    "summary": "- Computed properties are used for complex logic that includes reactive data\n- Computed properties automatically track their reactive dependencies\n- Computed properties are cached based on their reactive dependencies\n- Methods are an alternative to computed properties, but they are not cached\n- Computed properties are getter-only by default, but can be made writable by providing a setter\n- Getters in computed properties should be side-effect free and avoid async requests or DOM mutations\n- Computed values should be treated as read-only and not mutated"
  },
  {
    "title": "conditional",
    "path": "guide/essentials/composition/conditional.composition.md",
    "summary": "- The page is about conditional rendering in Vue.js\n- It explains how to use the `v-if` directive to conditionally render a block\n- It mentions the `v-else` directive to indicate an \"else block\" for `v-if`\n- It introduces the `v-else-if` directive to serve as an \"else if block\" for `v-if`\n- It explains how to use `v-if` on a `<template>` element to toggle multiple elements\n- It introduces the `v-show` directive as an alternative to `v-if` for conditional display\n- It compares the differences between `v-if` and `v-show`\n- It warns against using `v-if` and `v-for` on the same element"
  },
  {
    "title": "event-handling",
    "path": "guide/essentials/composition/event-handling.composition.md",
    "summary": "- The page explains how to handle events in Vue.js using the `v-on` directive or the `@` symbol.\n- It describes how to use inline handlers and method handlers to execute JavaScript code when an event is triggered.\n- The page also explains how to call methods in inline handlers and access the event argument.\n- It introduces event modifiers, such as `.stop`, `.prevent`, `.self`, `.capture`, `.once`, and `.passive`, which can be used with `v-on` to modify the behavior of event handlers.\n- The page also explains key modifiers and system modifier keys that can be used with keyboard and mouse events.\n- It provides examples and links to additional resources for each concept."
  },
  {
    "title": "forms",
    "path": "guide/essentials/composition/forms.composition.md",
    "summary": "- The page explains how to use the `v-model` directive to simplify form input bindings in Vue.js\n- It provides examples of using `v-model` with different types of form elements such as text inputs, checkboxes, radio buttons, and select dropdowns\n- The page also mentions modifiers for `v-model` such as `.lazy`, `.number`, and `.trim`\n- It mentions that `v-model` can be used with custom components as well"
  },
  {
    "title": "lifecycle",
    "path": "guide/essentials/composition/lifecycle.composition.md",
    "summary": "- Vue component instances go through initialization steps and run lifecycle hooks\n- The `onMounted` hook runs code after the component has finished initial rendering and created DOM nodes\n- Other commonly used hooks include `onUpdated` and `onUnmounted` (or `mounted`, `updated`, and `unmounted` in the options API)\n- Hooks need to be registered synchronously during component setup\n- There is a diagram for the instance lifecycle\n- Consult the Lifecycle Hooks API reference for more details on all lifecycle hooks and their use cases."
  },
  {
    "title": "list",
    "path": "guide/essentials/composition/list.composition.md",
    "summary": "- `v-for` directive is used to render a list of items based on an array\n- The syntax for `v-for` is `item in items`, where `items` is the source data array and `item` is an alias for the array element being iterated on\n- `v-for` supports an optional second alias for the index of the current item\n- `v-for` can also be used to iterate through the properties of an object\n- `v-for` can take an integer to repeat the template that many times\n- `v-for` can be used with a `<template>` tag to render a block of multiple elements\n- `v-for` and `v-if` should not be used on the same element, but can be used together by wrapping `v-for` in a `<template>` tag\n- `v-for` can be used on a component, but data needs to be passed to the component using props\n- Vue can detect changes to an array when using mutation methods such as `push()`, `pop()`, etc.\n- When replacing an array with a new array, Vue efficiently updates the DOM by reusing existing elements\n- To display filtered or sorted results, computed properties or methods can be used"
  },
  {
    "title": "reactivity-fundamentals",
    "path": "guide/essentials/composition/reactivity-fundamentals.composition.md",
    "summary": "- The page explains how to declare reactive state using the `ref()` function in the Composition API\n- It shows how to access and mutate the value of a ref using the `.value` property\n- The page also explains how to use refs in a component's template and how to mutate a ref directly in event handlers\n- It introduces the `<script setup>` syntax as a simplified way to declare reactive state in Single-File Components\n- The page explains the concept of deep reactivity and how refs can hold any value type, including nested objects and arrays\n- It mentions the use of the `nextTick()` function to wait for DOM updates after mutating reactive state\n- The page introduces the `reactive()` function as an alternative way to declare reactive state, making an object itself reactive\n- It explains the difference between a reactive object and its original object, and recommends using the proxied versions of reactive state\n- The page mentions the limitations of the `reactive()` API, such as its limited value types and the inability to replace the entire object\n- It provides additional details about ref unwrapping, including how refs are automatically unwrapped when accessed as properties of reactive objects and caveats when unwrapping in templates"
  },
  {
    "title": "template-refs",
    "path": "guide/essentials/composition/template-refs.composition.md",
    "summary": "- The `ref` attribute in Vue.js allows direct access to the underlying DOM elements or child component instances\n- The `ref` attribute can be used to obtain a direct reference to a specific DOM element or child component instance after it's mounted\n- The `ref` attribute can be accessed using the `$refs` property in the Options API or the declared ref in the Composition API\n- When using the Composition API, the ref must be declared with the same name as the template ref value\n- The ref can only be accessed after the component is mounted\n- When using a template ref inside a `v-for` loop, the corresponding ref should contain an Array value that will be populated with the elements after mount\n- The ref array does not guarantee the same order as the source array\n- The `ref` attribute can also be bound to a function, which will be called on each component update and gives flexibility on where to store the element reference\n- The `ref` attribute can be used on a child component, and the reference will be that of a component instance\n- The referenced instance of a child component will be identical to the child component's `this`, allowing access to every property and method of the child component\n- Components using `<script setup>` are private by default, but can expose a public interface using the `defineExpose` macro"
  },
  {
    "title": "template-syntax",
    "path": "guide/essentials/composition/template-syntax.composition.md",
    "summary": "- Vue uses an HTML-based template syntax for data binding\n- Templates are compiled into optimized JavaScript code\n- Text interpolation is done using double curly braces (`{{ }}`)\n- Raw HTML can be rendered using the `v-html` directive\n- Attribute bindings are done using the `v-bind` directive or its shorthand (`:`)\n- Boolean attributes can be bound using `v-bind` with a truthy value\n- Multiple attributes can be bound using `v-bind` without an argument\n- JavaScript expressions can be used in data bindings\n- Directives are special attributes with the `v-` prefix\n- Directives can have arguments and modifiers for special behavior"
  },
  {
    "title": "watchers",
    "path": "guide/essentials/composition/watchers.composition.md",
    "summary": "- The page is about using the `watch` function in Vue.js to perform side effects in reaction to state changes.\n- It provides a basic example of using `watch` to update the DOM based on the user's input.\n- It explains the different types of reactive sources that can be used with `watch`, such as refs, reactive objects, and getter functions.\n- It mentions that watching a property of a reactive object requires using a getter function instead of passing the property directly.\n- It explains how to create deep watchers that trigger the callback on all nested mutations of a reactive object.\n- It mentions the caution of using deep watchers on large data structures due to performance implications.\n- It explains how to create eager watchers that execute the callback immediately.\n- It introduces the `watchEffect` function as a simplified alternative to `watch` for tracking reactive dependencies.\n- It compares `watch` and `watchEffect`, stating that `watch` allows more precise control over when the callback should fire, while `watchEffect` automatically tracks all reactive properties accessed during its synchronous execution.\n- It explains how to specify the flush timing of watcher callbacks to access the DOM after Vue has updated it.\n- It mentions the automatic stopping of watchers created synchronously inside `setup()` or `<script setup>`, and the need to manually stop watchers created asynchronously to avoid memory leaks."
  },
  {
    "title": "animation",
    "path": "guide/extras/composition/animation.composition.md",
    "summary": "- The page discusses animation techniques in Vue.js\n- It mentions the `<Transition>` and `<TransitionGroup>` components for handling transitions\n- It explains how to use class-based animations by dynamically adding a CSS class\n- It demonstrates state-driven animations by interpolating values and binding styles to elements\n- It shows how to animate with watchers by using numerical state and the `watch` function"
  },
  {
    "title": "composition-api-faq",
    "path": "guide/extras/composition/composition-api-faq.composition.md",
    "summary": "- Composition API is a set of APIs for authoring Vue components using imported functions instead of declaring options\n- It includes the Reactivity API with functions like `ref()` and `reactive()`, Lifecycle Hooks with functions like `onMounted()` and `onUnmounted()`, and Dependency Injection with functions like `provide()` and `inject()`\n- Composition API allows for better logic reuse and more flexible code organization\n- It provides better type inference and a smaller production bundle compared to the Options API\n- Composition API can be used alongside the Options API in the same component\n- Options API will not be deprecated and remains a solid choice for low-to-medium complexity scenarios\n- Class API is no longer recommended in Vue 3, as Composition API provides similar capabilities with additional benefits\n- Composition API provides the same level of logic composition as React Hooks, but with some important differences, such as not being call-order sensitive and not requiring manual dependency management"
  },
  {
    "title": "reactivity-in-depth",
    "path": "guide/extras/composition/reactivity-in-depth.composition.md",
    "summary": "- Reactivity is a programming paradigm that allows for adjusting to changes in a declarative manner\n- Vue's reactivity system is unobtrusive and uses reactive JavaScript objects\n- The system tracks dependencies and updates the view when the state changes\n- JavaScript does not have built-in reactivity, but it can be achieved using functions and proxies\n- Vue uses proxies to intercept property access and trigger reactivity\n- The `reactive` function creates a reactive object using a proxy\n- The `ref` function creates a reactive reference using getter/setter\n- Effects are functions that automatically track their dependencies and re-run when a dependency changes\n- Vue provides the `watchEffect` and `computed` functions to create reactive effects\n- Debugging reactivity can be done using component debugging hooks, computed debugging, and watcher debugging\n- Vue's reactivity system can be integrated with external state systems such as Immer, state machines, and RxJS\n- Signals in other frameworks have similar concepts to Vue's refs, but with different API designs"
  },
  {
    "title": "reactivity-transform",
    "path": "guide/extras/composition/reactivity-transform.composition.md",
    "summary": "- Reactivity Transform is a deprecated experimental feature in Vue.js\n- It was a Composition-API-specific feature that required a build step\n- The feature allowed for writing code using `$ref()` to create reactive variables\n- The feature provided macros for reactivity APIs such as `ref`, `computed`, `shallowRef`, `customRef`, and `toRef`\n- Destructuring with the `$()` macro allowed for retrieving refs from objects\n- The `$()` macro could also be used to convert existing refs into reactive variables\n- The feature also addressed issues with `defineProps()` usage and retaining reactivity across function boundaries\n- TypeScript integration was supported and the macros had typings\n- The feature required an explicit opt-in configuration in tools like Vite and vue-cli"
  },
  {
    "title": "render-function",
    "path": "guide/extras/composition/render-function.composition.md",
    "summary": "- The page discusses the usage of render functions and JSX in Vue.js\n- It explains how to create vnodes using the `h()` function\n- It shows the basic usage of the `h()` function with different arguments\n- It explains how to declare render functions and return them from the `setup()` hook\n- It discusses the need for unique vnodes in the component tree\n- It explains how to use JSX and TSX in Vue.js\n- It provides examples of rendering templates features as equivalent render functions or JSX\n- It explains how to work with components in render functions and JSX\n- It explains how to render slots and pass slots as functions\n- It explains how to use built-in components like `<KeepAlive>`, `<Transition>`, `<TransitionGroup>`, `<Teleport>`, and `<Suspense>`\n- It explains how to use the `v-model` directive in render functions\n- It explains how to use custom directives in render functions\n- It explains how to work with template refs in render functions\n- It explains how to create functional components in Vue.js\n- It provides examples of typing functional components in TypeScript"
  },
  {
    "title": "rendering-mechanism",
    "path": "guide/extras/composition/rendering-mechanism.composition.md",
    "summary": "- Vue's rendering mechanism is based on the concept of virtual DOM\n- Virtual DOM is a programming concept where an ideal representation of a UI is kept in memory and synced with the real DOM\n- Vue uses a runtime renderer to create actual DOM nodes from a virtual DOM tree\n- The virtual DOM tree can be created using a plain JavaScript object called vnode\n- Mounting is the process of creating actual DOM nodes from a virtual DOM tree\n- Patching is the process of comparing two virtual DOM trees and applying necessary updates to the actual DOM\n- Vue templates are compiled into render functions that return virtual DOM trees\n- Templates are easier to use and understand, while render functions provide more flexibility\n- Vue's template compiler applies optimizations to improve the performance of the virtual DOM\n- Static hoisting optimizes the creation and diffing of static parts of the template\n- Patch flags provide information about the type of updates needed for dynamic elements\n- Tree flattening reduces the number of nodes that need to be traversed during reconciliation\n- These optimizations also improve Vue's SSR Hydration performance."
  },
  {
    "title": "ways-of-using-vue",
    "path": "guide/extras/composition/ways-of-using-vue.composition.md",
    "summary": "- Vue can be used as a standalone script file without a build step\n- Vue can be used to build standard Web Components\n- Vue is suitable for building Single-Page Applications (SPAs) with rich interactivity and navigation\n- Vue supports Server-Side Rendering (SSR) for improved performance and SEO\n- Vue can be used for Static-Site Generation (SSG) to pre-render and serve static HTML files\n- Vue can be used to build desktop and mobile apps with frameworks like Electron, Tauri, Ionic Vue, and Quasar\n- Vue's Custom Renderer API allows for building custom renderers targeting WebGL or the terminal."
  },
  {
    "title": "web-components",
    "path": "guide/extras/composition/web-components.composition.md",
    "summary": "- Vue and Web Components are complementary technologies\n- Vue has excellent support for consuming and creating custom elements\n- Vue scores a perfect 100% in the Custom Elements Everywhere tests\n- Vue can skip component resolution for certain elements using `compilerOptions.isCustomElement` option\n- Complex data can be passed to custom elements as DOM properties using `.prop` modifier\n- Vue supports creating custom elements using the `defineCustomElement` method\n- Vue custom elements mount an internal Vue component instance inside their shadow root\n- Props declared using the `props` option are defined on the custom element as properties\n- Events emitted in Vue custom elements are dispatched as native CustomEvents\n- Slots can be rendered using the `<slot/>` element in Vue custom elements\n- Provide/Inject API works between Vue-defined custom elements\n- Vue Single-File Components (SFCs) can be used as custom elements\n- Vue custom elements rely on Vue's runtime and have a baseline size cost\n- Global component typings can be registered for Vue components used as custom elements\n- Web Components APIs are low-level and lack certain capabilities provided by Vue components\n- Custom elements have limitations in component composition and scoped CSS"
  },
  {
    "title": "composables",
    "path": "guide/reusability/composition/composables.composition.md",
    "summary": "- A \"composable\" is a function that encapsulates and reuses stateful logic in Vue applications\n- Composables leverage Vue's Composition API\n- Composables can be used to extract logic from components and reuse it in multiple components\n- Composables can be nested and composed together to create complex logic\n- Composables should be named with camelCase and start with \"use\"\n- Composables can accept refs, getters, and plain values as input arguments\n- Composables should return a plain object containing multiple refs for better reactivity\n- Side effects in composables should be cleaned up in the `onUnmounted` hook\n- Composables can be used in the Options API by calling them inside the `setup` function and returning the desired properties\n- Composables are recommended over mixins and renderless components for better code organization and performance\n- Composables are similar to React hooks, but based on Vue's reactivity system"
  },
  {
    "title": "custom-directives",
    "path": "guide/reusability/composition/custom-directives.composition.md",
    "summary": "- Custom directives allow for reusing logic that involves low-level DOM access on plain elements\n- A custom directive is defined as an object containing lifecycle hooks similar to those of a component\n- The `mounted` hook focuses an input element when it is inserted into the DOM\n- Custom directives can be registered using the `directives` option or globally at the app level\n- Directive hooks include `created`, `beforeMount`, `mounted`, `beforeUpdate`, `updated`, `beforeUnmount`, and `unmounted`\n- Directive hooks receive arguments such as the element, binding, vnode, and prevVnode\n- Custom directives can be defined as functions for shorthand syntax\n- Multiple values can be passed to a directive using an object literal\n- Custom directives applied to components will always apply to the component's root node"
  },
  {
    "title": "plugins",
    "path": "guide/reusability/composition/plugins.composition.md",
    "summary": "- Plugins are self-contained code that add app-level functionality to Vue.js\n- Plugins can be installed using the `app.use()` method\n- Plugins can be defined as objects with an `install()` method or as functions that act as the install function itself\n- Common scenarios where plugins are useful include registering global components or directives, making a resource injectable throughout the app, adding global instance properties or methods, and combining multiple functionalities\n- Writing a plugin involves creating an object or function with an `install()` method\n- Plugins can provide globally available functions by attaching them to `app.config.globalProperties`\n- Plugins can also use `app.provide()` to make certain attributes or functions injectable to the plugin's users\n- Plugin options can be injected into components using the `inject` function"
  },
  {
    "title": "routing",
    "path": "guide/scaling-up/composition/routing.composition.md",
    "summary": "- Server-side routing involves the server sending a response based on the URL path, while client-side routing is done in the browser using JavaScript.\n- Single-Page Applications (SPAs) use client-side routing to dynamically fetch new data and update the current page without full page reloads.\n- The Vue Router library is the officially-supported router for building SPAs with Vue.js.\n- If you only need simple routing and don't want to use a router library, you can use dynamic components and listen to browser events like `hashchange` or use the History API."
  },
  {
    "title": "sfc",
    "path": "guide/scaling-up/composition/sfc.composition.md",
    "summary": "- Vue Single-File Components (SFC) allow encapsulation of template, logic, and styling in a single file\n- SFC is an extension of HTML, CSS, and JavaScript\n- SFC provides benefits such as modularization, colocation, pre-compiled templates, component-scoped CSS, ergonomic syntax, IDE support, and HMR support\n- SFC is recommended for SPAs, SSG, and non-trivial frontends\n- SFC must be pre-compiled into JavaScript and CSS\n- `<style>` tags can be injected during development and extracted into a single CSS file for production\n- SFC compiler can be integrated with build tools like Vite or Vue CLI\n- SFC promotes loose coupling and composition of components\n- Separation of concerns is not equal to separation of file types"
  },
  {
    "title": "ssr",
    "path": "guide/scaling-up/composition/ssr.composition.md",
    "summary": "- Server-Side Rendering (SSR) allows rendering Vue components into HTML strings on the server\n- SSR provides faster time-to-content, unified mental model, and better SEO\n- Trade-offs of SSR include development constraints, more involved build setup, and increased server-side load\n- SSR can be used when time-to-content is critical for the app\n- Static Site Generation (SSG) is an alternative technique for fast websites that generates static HTML files\n- Nuxt, Quasar, and Vite SSR are recommended higher-level solutions for SSR in the Vue ecosystem\n- SSR-friendly code requires considerations for reactivity on the server, component lifecycle hooks, access to platform-specific APIs, cross-request state pollution, hydration mismatch, custom directives, and teleports"
  },
  {
    "title": "state-management",
    "path": "guide/scaling-up/composition/state-management.composition.md",
    "summary": "- State management in Vue.js involves managing the reactive state of a component\n- State consists of the source of truth, the view, and actions\n- When multiple components share a common state, it can lead to issues such as prop drilling and unmaintainable code\n- A solution is to extract the shared state and manage it in a global singleton\n- The `reactive()` function can be used to create a reactive object for shared state\n- Methods can be defined on the store object to centralize state-mutating logic\n- The store object can be imported into multiple components to share state\n- It is recommended to use methods on the store object to mutate state, rather than directly mutating it\n- Other reactive state created using `ref()` or `computed()` can also be shared\n- Vue's reactivity system is flexible and can be decoupled from the component model\n- Considerations for server-side rendering (SSR) are discussed in the documentation\n- Pinia is a state management library for Vue.js that provides stronger conventions and additional features\n- Pinia is recommended for new applications and offers a simpler API and solid type inference support"
  },
  {
    "title": "testing",
    "path": "guide/scaling-up/composition/testing.composition.md",
    "summary": "- The page is about testing in Vue.js\n- It covers the importance of automated tests in building complex Vue applications\n- It discusses when to start testing and the different types of testing (unit, component, end-to-end)\n- It provides an overview of each testing type and their role in the application's testing strategy\n- It specifically focuses on unit testing and provides an example of how to write unit tests for a function\n- It mentions that unit testing can be applied to business logic, components, classes, modules, and functions\n- It explains that unit testing for Vue-specific features can be done for composables and components\n- It provides recommendations for unit testing frameworks, including Vitest and Peeky\n- It also discusses component testing and provides recommendations for component testing frameworks, including Vitest and Cypress\n- It explains how to test components using whitebox and blackbox approaches\n- It provides recommendations for E2E testing frameworks, including Cypress\n- It explains the importance of E2E testing and its coverage of multi-page application behavior\n- It provides recommendations for choosing an E2E testing solution, including Cypress\n- It mentions other options for E2E testing, such as Nightwatch and WebdriverIO\n- It includes a section on recipes, including adding Vitest to a project and testing composables"
  },
  {
    "title": "TestingApiSwitcher.vue",
    "path": "guide/scaling-up/composition/TestingApiSwitcher.vue.composition.md",
    "summary": "- This page is about a Vue.js component for displaying code examples with tabs.\n- The page uses the `ref` function from Vue.js to create a reactive reference to the active tab.\n- The component has a `testingLangs` array that contains objects with labels and class names for each tab.\n- The template of the component renders the tabs and the code example based on the active tab.\n- The component has scoped styles for the layout and styling of the tabs.\n- The component uses CSS classes and reactive classes to show and hide the code examples based on the active tab."
  },
  {
    "title": "tooling",
    "path": "guide/scaling-up/composition/tooling.composition.md",
    "summary": "- Online playgrounds for trying out Vue SFCs in the browser: Vue SFC Playground, Vue + Vite on StackBlitz\n- Project scaffolding tools: Vite and Vue CLI\n- In-browser template compilation options and considerations\n- Recommended IDE support: VSCode with Vue Language Features (Volar) extension, WebStorm\n- Vue browser devtools for debugging and profiling Vue apps\n- TypeScript support with Volar and vue-tsc\n- Testing options: Cypress, Vitest, Jest\n- Linting with eslint-plugin-vue\n- Formatting with Volar or Prettier\n- Integrating custom blocks in SFCs with Vite and Vue CLI/webpack\n- Lower-level packages: @vue/compiler-sfc, @vitejs/plugin-vue, vue-loader\n- Other online playgrounds for Vue.js"
  },
  {
    "title": "composition-api",
    "path": "guide/typescript/composition/composition-api.composition.md",
    "summary": "- `defineProps()` macro supports inferring props types based on its argument\n- `defineProps()` can be used with type-based declaration or runtime declaration\n- `withDefaults` compiler macro can be used to declare default values for props\n- When not using `<script setup>`, `defineComponent()` is used to enable props type inference\n- Props can use complex types with type-based declaration or `PropType` utility type with runtime declaration\n- `ref()` infers the type from the initial value, but can also be explicitly typed with the `Ref` type or a generic argument\n- `reactive()` infers the type from its argument, but can also be explicitly typed with interfaces\n- `computed()` infers its type based on the getter's return value, but can also be explicitly typed with a generic argument\n- Event handlers should be explicitly annotated with the correct argument type\n- `provide` and `inject` can be typed using `InjectionKey` interface or a generic type argument\n- Template refs should be created with an explicit generic type argument and an initial value of `null`\n- Template refs for child components can be annotated using `typeof` and `InstanceType` to get the instance type\n- `ComponentPublicInstance` can be used when the exact type of the component is not available or important"
  },
  {
    "title": "options-api",
    "path": "guide/typescript/composition/options-api.composition.md",
    "summary": "- The page discusses typing component props in the Options API\n- It explains how to use the `defineComponent()` function to enable type inference for props\n- It mentions the `PropType` utility type for annotating complex props types\n- The page mentions a caveat for TypeScript versions less than 4.7 when using function values for `validator` and `default` prop options\n- It explains how to type emitted events using the `emits` option\n- The page discusses typing computed properties and when explicit annotations may be required\n- It explains how to type event handlers and recommends annotating the argument of event handlers\n- The page discusses augmenting global properties using the `ComponentCustomProperties` interface\n- It explains the placement of type augmentations and the need to be in a TypeScript module\n- The page also discusses augmenting custom options for plugins like `vue-router`"
  },
  {
    "title": "overview",
    "path": "guide/typescript/composition/overview.composition.md",
    "summary": "- Vue provides first-class TypeScript support\n- Use `create-vue` to scaffold a Vite-powered, TypeScript-ready Vue project\n- During development, rely on IDE setup for instant feedback on type errors\n- Use `vue-tsc` utility for command line type checking and type declaration generation\n- Configure `tsconfig.json` with options like `isolatedModules`, `strict`, and `paths`\n- Use Visual Studio Code or WebStorm for TypeScript support\n- Enable Volar Takeover Mode for improved performance in VSCode\n- TypeScript can be used in single-file components with `lang=\"ts\"` or `<script setup lang=\"ts\">`\n- TypeScript can be used in templates with `<script lang=\"ts\">` or `<script setup lang=\"ts\">`\n- TypeScript is supported in JSX / TSX components\n- Generic components are supported in SFCs and render function / JSX components\n- API-specific recipes are available for using TypeScript with Composition API and Options API"
  }
]